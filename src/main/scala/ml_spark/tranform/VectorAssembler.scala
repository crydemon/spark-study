package ml_spark.tranform

import org.apache.spark.ml.Pipeline
import org.apache.spark.ml.feature.StringIndexer

//def:
//Vectors.dense(values: Array[Double])
//(直接把所有的元素都列出来了)
//
//SparseVector : an index and a value array
//
//def:
//Vectors.sparse(size: Int, indices: Array[Int], values: Array[Double])
//(存储元素的个数、以及非零元素的编号index和值value)

//VectorAssembler is a transformer that combines a given list of columns into a single vector column.
// It is useful for combining raw features and features generated by different feature transformers into a single feature vector,
// in order to train ML models like logistic regression and decision trees.
// VectorAssembler accepts the following input column types:
// all numeric types, boolean type, and vector type.
// In each row, the values of the input columns will be concatenated into a vector in the specified order.
object VectorAssembler extends App {

  import org.apache.spark.ml.feature.VectorAssembler
  import org.apache.spark.ml.linalg.Vectors

  val spark = utils.util.initSpark("VectorAssembler")
  val dataset = spark.createDataFrame(
    Seq((0, 18, 1.0, Vectors.dense(0.0, 10.0, 0.5), 1.0))
  ).toDF("id", "hour", "mobile", "userFeatures", "clicked")

  val assembler = new VectorAssembler()
    .setInputCols(Array("hour", "mobile", "userFeatures"))
    .setOutputCol("features")

  val output = assembler.transform(dataset)
  println("Assembled columns 'hour', 'mobile', 'userFeatures' to vector column 'features'")
  output.select("features", "clicked").show(false)
}
//This encoding allows algorithms which expect continuous features, such as Logistic Regression, to use categorical features.
//当类别的数量很多时，特征空间会变得非常大。在这种情况下，一般可以用PCA来减少维度。
// 而且one hot encoding+PCA这种组合在实际中也非常有用。
// 有些基于树的算法在处理变量时，并不是基于向量空间度量，数值只是个类别符号，即没有偏序关系，所以不用进行独热编码。
// Tree Model不太需要one-hot编码： 对于决策树来说，one-hot的本质是增加树的深度。
object OneHot extends App {

  import org.apache.spark.ml.feature.OneHotEncoderEstimator

  val spark = utils.util.initSpark("OneHot")
  import spark.implicits._
  val df = spark.createDataFrame(Seq(
    ("fs234df", 1.0),
    ("fs34df", 0.0),
    ("fsd23f", 1.0),
    ("f34sdf", 9.0),
    ("fs3df", 100.0),
    ("fsdfw2sdf", 0.0)
  )).toDF("category", "categoryIndex2")

  val stringIndex = new StringIndexer()
    .setInputCol("category")
    .setOutputCol("categoryIndex1")
  val encoder = new OneHotEncoderEstimator()
    .setInputCols(Array("categoryIndex1", "categoryIndex2"))
    .setOutputCols(Array("categoryVec1", "categoryVec2"))
    .setDropLast(false)
  val pipeline = new Pipeline().setStages(Array(stringIndex, encoder))
  val model = pipeline.fit(df)

  val encoded = model.transform(df)

  encoded.printSchema()
  encoded.show()

}
